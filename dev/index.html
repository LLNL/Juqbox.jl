<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Home · Juqbox.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Juqbox.jl</span></div><form class="docs-search" action="search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li class="is-active"><a class="tocitem" href="index.html">Home</a><ul class="internal"><li><a class="tocitem" href="#Installation"><span>Installation</span></a></li><li><a class="tocitem" href="#Workflow"><span>Workflow</span></a></li><li><a class="tocitem" href="#Examples"><span>Examples</span></a></li><li><a class="tocitem" href="#Exported-types"><span>Exported types</span></a></li><li><a class="tocitem" href="#Exported-functions"><span>Exported functions</span></a></li><li><a class="tocitem" href="#Index"><span>Index</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href="index.html">Home</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="index.html">Home</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LLNL/Juqbox.jl/blob/master/docs/src/index.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Juqbox.jl-Documentation"><a class="docs-heading-anchor" href="#Juqbox.jl-Documentation">Juqbox.jl Documentation</a><a id="Juqbox.jl-Documentation-1"></a><a class="docs-heading-anchor-permalink" href="#Juqbox.jl-Documentation" title="Permalink"></a></h1><h2 id="Installation"><a class="docs-heading-anchor" href="#Installation">Installation</a><a id="Installation-1"></a><a class="docs-heading-anchor-permalink" href="#Installation" title="Permalink"></a></h2><p>The following instructions assume that you have already installed Julia (currently version 1.5.3) on your system. Before installing Juqbox, we recommend that you add the following line to your .bash<em>profile (or corresponding file):&lt;br&gt; **export JULIA</em>PROJECT=&quot;@.&quot;**&lt;br&gt; This environment variable tells Julia to look for Project.toml files in your current or parent directory.</p><h3 id="Building-and-testing-**Juqbox**"><a class="docs-heading-anchor" href="#Building-and-testing-**Juqbox**">Building and testing <strong>Juqbox</strong></a><a id="Building-and-testing-**Juqbox**-1"></a><a class="docs-heading-anchor-permalink" href="#Building-and-testing-**Juqbox**" title="Permalink"></a></h3><p>shell&gt; julia&lt;br&gt; julia&gt; ]&lt;br&gt; (@v1.5) pkg&gt; add  https://github.com/LLNL/Juqbox.jl.git&lt;br&gt; (@v1.5) pkg&gt; precompile&lt;br&gt; (@v1.5) pkg&gt; test Juqbox&lt;br&gt; ... all tests should pass ...&lt;br&gt;</p><p>To exit the package manager and Julia you do&lt;br&gt; (@v1.5) pkg&gt; (DEL) &lt;br&gt; julia&gt; exit()</p><h2 id="Workflow"><a class="docs-heading-anchor" href="#Workflow">Workflow</a><a id="Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Workflow" title="Permalink"></a></h2><p>The work flow for solving a quantum optimal control problem consists of the following general steps:</p><ol><li>Specify the problem</li><li>Optimize</li><li>Visualize the results</li></ol><h3 id=".-Specifying-the-problem"><a class="docs-heading-anchor" href="#.-Specifying-the-problem">1. Specifying the problem</a><a id=".-Specifying-the-problem-1"></a><a class="docs-heading-anchor-permalink" href="#.-Specifying-the-problem" title="Permalink"></a></h3><p>The setup phase includes specifying</p><ul><li>The size of the state vector</li><li>The system and control Hamiltonians</li><li>The target gate transformation</li><li>Duration of the gate and number of time steps for integrating Schroedinger&#39;s equation.</li></ul><p>For the parameterization the control functions, you need to specify</p><ul><li>Carrier wave frequencies</li><li>Number of B-spline coefficients in each spline</li></ul><p>The properties of the control problem are stored in a <code>mutable struct</code> that is populated by calling</p><ul><li><code>params = Juqbox.objparams()</code>.</li></ul><p>The next steps are:</p><ul><li>Assign the initial parameter vector (called <code>pcof0</code> in the examples below)</li><li>Set bounds for the parameter vector to be imposed during the optimization</li><li>Allocate working arrays by calling <code>wa = Juqbox.Working_arrays()</code></li><li>Assign convergence criteria and other parameters for the optimizer</li><li>Build the optimization structure by calling <code>prob = Juqbox.setup_ipopt_problem()</code></li></ul><h3 id=".-Optimization"><a class="docs-heading-anchor" href="#.-Optimization">2. Optimization</a><a id=".-Optimization-1"></a><a class="docs-heading-anchor-permalink" href="#.-Optimization" title="Permalink"></a></h3><p>Once you have been assigned the <code>params</code> and <code>prob</code> objects, as well as the initial parameter vector  <code>pcof0</code>, the optimizer is invoked by</p><ul><li><code>pcof = Juqbox.run_optimizer(prob, pcof0 [, jld2_filename])</code></li></ul><h3 id=".-Visualizing-the-results"><a class="docs-heading-anchor" href="#.-Visualizing-the-results">3. Visualizing the results</a><a id=".-Visualizing-the-results-1"></a><a class="docs-heading-anchor-permalink" href="#.-Visualizing-the-results" title="Permalink"></a></h3><p>General properties of the optimized solution such as trace infidelity and unitary accuracy can be evaluated,  and a number of figures can generated by invoking</p><ul><li><code>pl = Juqbox.plot_results(params, pcof)</code></li></ul><p>An array of Julia plot objects is returned in <code>pl</code>. These objects can be visualized on the screen</p><ul><li><code>display(pl[1])</code></li></ul><p>where <code>pl[1]</code> is the first Julia plot object. The following plot objects are populated by the script: </p><ul><li><code>pl[1]</code> Evolution of the state vector population</li><li><code>pl[2]</code> Control functions in the rotating frame of reference</li><li><code>pl[3]</code> Population of forbidden energy levels</li><li><code>pl[4]</code> Lab frame control function(s)</li><li><code>pl[5]</code> Fourier transform of the lab-frame control functions (linear scale)</li><li><code>pl[6]</code> Fourier transform of the lab-frame control functions (log scale)</li><li><code>pl[7]</code> Coefficients of the optimized parameter vector</li><li><code>pl[8]</code> Convergence of the optimization</li></ul><h2 id="Examples"><a class="docs-heading-anchor" href="#Examples">Examples</a><a id="Examples-1"></a><a class="docs-heading-anchor-permalink" href="#Examples" title="Permalink"></a></h2><p>Examples of the setup procedure can be found in the scripts in the <code>Juqbox.jl/examples</code> directory. The examples are invoked by, e.g.</p><ul><li><code>include(&quot;cnot1-setup.jl&quot;)</code></li></ul><p>The following cases are included:</p><ul><li><code>rabi-setup.jl</code> Pi-pulse (X-gate) for a qubit, i.e. a Rabi oscillator.</li><li><code>cnot1-setup.jl</code> CNOT gate for a single qudit with 4 essential and 2 guard levels. </li><li><code>flux-setup.jl</code> CNOT gate for single qubit with a flux-tuning control Hamiltonian.</li><li><code>cnot2-setup.jl</code> CNOT gate for a pair of coupled qubits with guard levels.</li><li><code>cnot3-setup.jl</code> Cross-resonance CNOT gate for a pair of qubits that are coupled by a cavity resonator.</li></ul><p><strong>Note:</strong> This case reads an optimized solution from file.</p><h2 id="Exported-types"><a class="docs-heading-anchor" href="#Exported-types">Exported types</a><a id="Exported-types-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-types" title="Permalink"></a></h2><p>The following types are exported and available by <code>using Juqbox</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Juqbox.Working_Arrays" href="#Juqbox.Working_Arrays"><code>Juqbox.Working_Arrays</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">wa = Working_Arrays(params::objparams, nCoeff::Int64)</code></pre><p>Constructor for the mutable struct Working_Arrays containing preallocated working arrays.</p><p><strong>Arguments</strong></p><ul><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>nCoeff:: Int64</code>: Number of parameters in optimization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L228-L237">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.bcparams" href="#Juqbox.bcparams"><code>Juqbox.bcparams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">bcpar = bcparams(T, D1, Ncoupled, Nunc, omega, pcof)</code></pre><p>General constructor of struct bcparams for setting up B-splines with carrier waves.</p><pre><code class="language-none">bcpar = bcparams(T, D1, omega, pcof)</code></pre><p>Simplified constructor for the case when there are no uncoupled controls and <code>Ncoupled = size(omega,1)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Duration of spline function</li><li><code>D1:: Int64</code>: Number of basis functions in each segment</li><li><code>Ncoupled::Int64</code>: Number of coupled controls in the simulation</li><li><code>Nunc::Int64</code>: Number of uncoupled controls in the simulation</li><li><code>omega::Array{Float64,2}</code>: Carrier wave frequencies</li><li><code>pcof:: Array{Float64, 1}</code>: Coefficient vector. Must have D1*Nseg elements</li></ul><p><strong>First dimensions of the <code>omega</code> array:</strong></p><ul><li>With no uncoupled controls, <code>Nunc=0</code> and <code>size(omega,1) = Ncoupled</code>.</li><li>With uncoupled controls, <code>Nunc &gt; 0</code> and <code>size(omega,1) = Ncoupled + Nunc</code>.</li></ul><p><strong>Second dimension of the <code>omega</code> array:</strong></p><ul><li><code>size(omega, 2) = Nfreq</code></li></ul><p><strong>Ordering of the <code>pcof</code> array:</strong></p><p>First consider the case without uncoupled control functions, <code>Nunc = 0</code>:  Then the <code>pcof</code> array then has <code>2*Ncoupled*Nfreq*D1</code> elements.  Each <code>ctrl ∈ [1,Ncoupled]</code> and <code>freq ∈ [1,Nfreq]</code> corresponds to <code>D1</code> elements in  the <code>pcof</code> vector. For the case <code>Ncoupled = 2</code> and <code>Nfreq = 2</code>, the elements are ordered according to</p><table><tr><th style="text-align: right">ctrl</th><th style="text-align: right">freq</th><th style="text-align: right">α_1</th><th style="text-align: right">α_2</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">1</td><td style="text-align: right">1:D1</td><td style="text-align: right">D1+1:2 D1</td></tr><tr><td style="text-align: right">1</td><td style="text-align: right">2</td><td style="text-align: right">2 D1+1: 3 D1</td><td style="text-align: right">3 D1+1:4 D1</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">1</td><td style="text-align: right">4 D1+1: 5 D1</td><td style="text-align: right">5 D1+1:6 D1</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">2</td><td style="text-align: right">6 D1+1: 7 D1</td><td style="text-align: right">7 D1+1: 8D1</td></tr></table><p>If there are uncoupled controls, <code>Nunc &gt; 0</code>, the <code>pcof</code> array should have <code>(2*Ncoupled + Nunc)*Nfreq*D1</code> elements.  The last <code>Nunc*Nfreq*D1</code> elements correspond to the uncoupled control functions and are ordered in a corresponding way.</p><p><strong>External links</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Spline_wavelet#Quadratic_B-spline">Spline Wavelet</a> on Wikipedia.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/bsplines.jl#L117-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.objparams" href="#Juqbox.objparams"><code>Juqbox.objparams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">params = objparams(Ne, Ng, T, Nsteps;
                    Uinit=Uinit, 
                    Utarget=Utarget,
                    Cfreq=Cfreq, 
                    Rfreq=Rfreq, 
                    Hconst=Hconst [, 
                    Hsym_ops=Hsym_ops,
                    Hanti_ops=Hanti_ops, 
                    Hunc_ops=Hunc_ops,
                    wmatScale=wmatScale, 
                    use_sparse=use_sparse])</code></pre><p>Constructor for the mutable struct objparams. The sizes of the arrays in the argument list are based on <code>Ntot = prod(Ne + Ng)</code>, <code>Ness = prod(Ne)</code>, <code>Nosc = length(Ne) = length(Ng)</code>.</p><p>Notes: It is assumed that <code>length(Hsym_ops) = length(Hanti_ops) =: Ncoupled</code>. The matrices <code>Hconst</code>, <code>Hsym_ops[j]</code>and <code>Hanti_ops[j]</code>, for j∈[1,Ncoupled], must all be of size <code>Ntot × Ntot</code>. The matrices <code>Hsym_ops[j]</code> must be symmetric and <code>Hanti_ops[j]</code> must be skew-symmetric. The matrices <code>Hunc_ops[j]</code>, for j∈[1,Nunc], where <code>Nunc = length(Hunc_ops)</code>, must also be of size <code>Ntot × Ntot</code> and either be symmetric or skew-symmetric.</p><p><strong>Arguments</strong></p><ul><li><code>Ne::Array{Int64,1}</code>: Number of essential energy levels for each subsystem</li><li><code>Ng::Array{Int64,1}</code>: Number of guard energy levels for each subsystem</li><li><code>T::Float64</code>: Duration of gate</li><li><code>Nsteps::Int64</code>: Number of timesteps for integrating Schroedinger&#39;s equation</li><li><code>Uinit::Array{Float64,2}</code>: (keyword) Matrix holding the initial conditions for the solution matrix of size Uinit[Ntot, Ness]</li><li><code>Utarget::Array{Complex{Float64},2}</code>: (keyword) Matrix holding the target gate matrix of size Uinit[Ntot, Ness]</li><li><code>Cfreq::Array{Float64,2}</code>: (keyword) Carrier wave frequencies of size Cfreq[Ncoupled, Nfreq]</li><li><code>Rfreq::Array{Float64,2}</code>: (keyword) Rotational frequencies of size Rfreq[Nosc]</li><li><code>Hconst::Array{Float64,2}</code>: (keyword) Time-independent part of the Hamiltonian matrix of size Ntot × Ntot</li><li><code>Hsym_ops:: Array{Array{Float64,2},1}</code>: (keyword) Array of symmetric control Hamiltonians, each of size Ntot × Ntot</li><li><code>Hanti_ops:: Array{Array{Float64,2},1}</code>: (keyword) Array of anti-symmetric control Hamiltonians, each of size Ntot × Ntot</li><li><code>Hunc_ops:: Array{Array{Float64,2},1}</code>: (keyword) Array of uncoupled control Hamiltonians, each of size Ntot × Ntot</li><li><code>wmatScale::Float64 = 1.0</code>: (keyword) Scaling factor for suppressing guarded energy levels</li><li><code>use_sparse::Bool = false</code>: (keyword) Set to true to sparsify all Hamiltonian matrices</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L1-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.splineparams" href="#Juqbox.splineparams"><code>Juqbox.splineparams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">spar = splineparams(T, D1, Nseg, pcof)</code></pre><p>Constructor for struct splineparams, which sets up the parameters for a regular B-spline function (without carrier waves).</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Duration of spline function</li><li><code>D1:: Int64</code>: Number of basis functions in each spline</li><li><code>Nseg:: Int64</code>:  Number of splines (real, imaginary, different ctrl func)</li><li><code>pcof:: Array{Float64, 1}</code>: Coefficient vector. Must have D1*Nseg elements</li></ul><p><strong>External links</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Spline_wavelet#Quadratic_B-spline">Spline Wavelet</a> on Wikipedia.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/bsplines.jl#L1-L15">source</a></section></article><h2 id="Exported-functions"><a class="docs-heading-anchor" href="#Exported-functions">Exported functions</a><a id="Exported-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Exported-functions" title="Permalink"></a></h2><p>The following methods (functions) are exported and available by <code>using Juqbox</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Juqbox.assign_thresholds" href="#Juqbox.assign_thresholds"><code>Juqbox.assign_thresholds</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">minCoeff, maxCoeff = assign_thresholds(params, D1, maxpar [, maxpar_unc])</code></pre><p>Build vector of frequency independent min/max parameter constraints for each coupled and (optionally) uncoupled control function. Here, <code>minCoeff = -maxCoeff</code>.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct containing problem definition.</li><li><code>D1:: Int64</code>: Number of basis functions in each segment.</li><li><code>maxpar::Array{Float64,1}</code>: Maximum parameter value for each coupled control.</li><li><code>maxpar_unc::Array{Float64,1}=</code>: (optional) Maximum parameter value for each uncoupled control.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L1064-L1075">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.assign_thresholds_ctrl_freq-Tuple{objparams,Int64,Array{Float64,2}}" href="#Juqbox.assign_thresholds_ctrl_freq-Tuple{objparams,Int64,Array{Float64,2}}"><code>Juqbox.assign_thresholds_ctrl_freq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minCoeff, maxCoeff = assign_thresholds_ctrl_freq(params, D1, maxamp)</code></pre><p>Build vector of parameter min/max constraints that can depend on the control function and carrier wave frequency,  with <code>minCoeff = -maxCoeff</code>, assuming no uncoupled control functions.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct containing problem definition.</li><li><code>D1:: Int64</code>: Number of basis functions in each segment.</li><li><code>maxamp:: Matrix{Float64}</code>: <code>maxamp[c,f]</code> is the maximum parameter value for ctrl <code>c</code> and frequency <code>f</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L1005-L1015">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.assign_thresholds_freq-Tuple{Array{Float64,1},Int64,Int64,Int64}" href="#Juqbox.assign_thresholds_freq-Tuple{Array{Float64,1},Int64,Int64,Int64}"><code>Juqbox.assign_thresholds_freq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">minCoeff, maxCoeff = assign_thresholds_freq(maxamp, Ncoupled, Nfreq, D1)</code></pre><p>Build vector of frequency dependent min/max parameter constraints, with <code>minCoeff = -maxCoeff</code>, when there are no uncoupled control functions.</p><p><strong>Arguments</strong></p><ul><li><code>maxamp::Array{Float64,1}</code>: Maximum parameter value for each frequency</li><li><code>Ncoupled::Int64</code>: Number of coupled controls in the simulation</li><li><code>Nfreq::Int64</code>: Number of carrier wave frequencies used in the controls</li><li><code>D1:: Int64</code>: Number of basis functions in each control function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L1036-L1047">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.bcarrier2-Tuple{Float64,bcparams,Int64}" href="#Juqbox.bcarrier2-Tuple{Float64,bcparams,Int64}"><code>Juqbox.bcarrier2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = bcarrier2(t, params, func)</code></pre><p>Evaluate a B-spline function with carrier waves. See also the <code>bcparams</code> constructor.</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Evaluate spline at parameter t ∈ [0, param.T]</li><li><code>param::params</code>: Parameters for the spline</li><li><code>func::Int64</code>: Spline function index ∈ [0, param.Nseg-1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/bsplines.jl#L214-L223">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.bspline2-Tuple{Float64,splineparams,Int64}" href="#Juqbox.bspline2-Tuple{Float64,splineparams,Int64}"><code>Juqbox.bspline2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">f = bspline2(t, splineparam, splinefunc)</code></pre><p>Evaluate a B-spline function. See also the <code>splineparams</code> constructor.</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Evaluate spline at parameter t ∈ [0, param.T]</li><li><code>param::splineparams</code>: Parameters for the spline</li><li><code>splinefunc::Int64</code>: Spline function index ∈ [0, param.Nseg-1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/bsplines.jl#L35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.calculate_timestep" href="#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nsteps = calculate_timestep(T, H0, Hunc_ops, maxpar [, Pmin = 40])</code></pre><p>Estimate the number of time steps needed for an accurate simulation, when there are no coupled controls</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Final simulation</li><li><code>H0::Array{Float64,2}</code>: Time-independent part of the Hamiltonian matrix</li><li><code>Hunc_ops:: Array{Float64,2}</code>: Array of uncoupled control Hamiltonians</li><li><code>max_unc:: Array{Float64,1}</code>: Maximum parameter value for each subsystem (uncoupled)</li><li><code>Pmin:: Int64</code>: Sample rate for accuracy (assuming a slowly varying Hamiltonian)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L1937-L1948">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.calculate_timestep" href="#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nsteps = calculate_timestep(T, H0, Hsym_ops, Hanti_ops, maxpar [, Pmin = 40])</code></pre><p>Estimate the number of time steps needed for the simulation, for the case without uncoupled controls.</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Final simulation</li><li><code>H0::Array{Float64,2}</code>: Time-independent part of the Hamiltonian matrix</li><li><code>Hsym_ops:: Array{Float64,2}</code>: Array of symmetric control Hamiltonians</li><li><code>Hanti_ops:: Array{Float64,2}</code>: Array of symmetric control Hamiltonians</li><li><code>maxpar:: Array{Float64,1}</code>: Maximum parameter value for each subsystem</li><li><code>Pmin:: Int64</code>: Number of time steps per shortest period (assuming a slowly varying Hamiltonian).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L1843-L1855">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.calculate_timestep" href="#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nsteps = calculate_timestep(T, H0, Hsym_ops, Hanti_ops, Hunc_ops, 
                                          maxpar, max_flux[, Pmin = 40])</code></pre><p>Estimate the number of time steps needed for the simulation, when there are uncoupled controls.</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Final simulation</li><li><code>H0::Array{Float64,2}</code>: Time-independent part of the Hamiltonian matrix</li><li><code>Hsym_ops:: Array{Float64,2}</code>: Array of symmetric control Hamiltonians</li><li><code>Hanti_ops:: Array{Float64,2}</code>: Array of symmetric control Hamiltonians</li><li><code>Hunc_ops:: Array{Float64,2}</code>: Array of uncoupled control Hamiltonians</li><li><code>maxpar:: Array{Float64,1}</code>: Maximum parameter value for each coupled control</li><li><code>max_flux:: Array{Float64,1}</code>: Maximum parameter value for each uncoupled control</li><li><code>Pmin:: Int64</code>: Number of time steps per shortest period (assuming a slowly varying Hamiltonian).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L1879-L1894">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.estimate_Neumann!" href="#Juqbox.estimate_Neumann!"><code>Juqbox.estimate_Neumann!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">estimate_Neumann!(tol, params, maxpar[, maxunc])</code></pre><p>Estimate the number of terms needed by the Neumann series approach for solving the linear system during the implicit steps of the Störmer-Verlet scheme. See also neumann!</p><p><strong>Arguments</strong></p><ul><li><code>tol:: Float64</code>: Error tolerance in inverting implicit SV term</li><li><code>params:: objparams</code>: Struct containing problem definition</li><li><code>maxpar:: Array{Float64,1}</code>: Maximum parameter value for each coupled control</li><li><code>maxunc:: Array{Float64,1}</code>: (optional) Maximum parameter value for each uncoupled controls</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L1792-L1803">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.evalctrl-Tuple{objparams,Array{Float64,1},Array{Float64,1},Int64}" href="#Juqbox.evalctrl-Tuple{objparams,Array{Float64,1},Array{Float64,1},Int64}"><code>Juqbox.evalctrl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pj [, qj] = evalctrl(params, pcof0, td, func)</code></pre><p>Evaluate the control function with index <code>func</code> at an array of time levels <code>td</code>.  </p><p>NOTE: the control function index <code>func</code> is 1-based. </p><p>NOTE: The return value(s) depend on <code>func</code>. For <code>func∈[1,Ncoupled]</code>, <code>pj, qj</code> are returned. Otherwise,  only <code>pj</code> is returned, corresponding to control number <code>func</code>.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>pcof0:: Array{Float64,1})</code>: Vector of parameter values</li><li><code>td:: Array{Float64,1})</code>: Time values control is to be evaluated</li><li><code>jHam:: Int64</code>: Index of the control signal desired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/plotstatectrl.jl#L214-L229">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.gradbcarrier2!-Tuple{Float64,bcparams,Int64,Array{Float64,1}}" href="#Juqbox.gradbcarrier2!-Tuple{Float64,bcparams,Int64,Array{Float64,1}}"><code>Juqbox.gradbcarrier2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">gradbcarrier2!(t, params, func, g) -&gt; g</code></pre><p>Evaluate the gradient of a control function with respect to all coefficient.</p><p>NOTE: the index of the control functions is 0-based. For a set of  coupled controls, mod(<code>func</code>,2)=0 corresponds to ∇ p<em>j(t) and mod(<code>func</code>,2) = 1  corresponds to ∇ q</em>j(t), where j = div(func,2).</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Evaluate spline at parameter t ∈ [0, param.T]</li><li><code>params::bcparams</code>: Parameters for the spline</li><li><code>func::Int64</code>: Control function index ∈ [0, param.Nseg-1]</li><li><code>g::Array{Float64,1}</code>: Preallocated array to store calculated gradient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/bsplines.jl#L321-L334">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.gradbspline2-Tuple{Float64,splineparams,Int64}" href="#Juqbox.gradbspline2-Tuple{Float64,splineparams,Int64}"><code>Juqbox.gradbspline2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">g = gradbspline2(t, param, splinefunc)</code></pre><p>Evaluate the gradient of a spline function with respect to all coefficient. NOTE: the index of the spline functions are 0-based. For a set of  coupled controls, mod(<code>splinefunc</code>,2)=0 corresponds to ∇ p<em>j(t) and mod(<code>splinefunc</code>,2) = 1  corresponds to ∇ q</em>j(t), where j = div(splinefunc,2).</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Evaluate spline at parameter t ∈ [0, param.T]</li><li><code>param::splineparams</code>: Spline parameter object</li><li><code>splinefunc::Int64</code>: Spline function index ∈ [0, param.Nseg-1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/bsplines.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.identify_forbidden_levels" href="#Juqbox.identify_forbidden_levels"><code>Juqbox.identify_forbidden_levels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">forbiddenlev = identify_guard_levels(params[, custom = 0])</code></pre><p>Build a Bool array indicating which energy levels are forbidden levels in the state vector. The forbidden levels in a state vector are defined as thos corresponding to the highest energy level in at least one of its subsystems.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>custom:: Int64</code>: For nonzero value special stirap pulses case</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/plotstatectrl.jl#L313-L323">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.identify_guard_levels" href="#Juqbox.identify_guard_levels"><code>Juqbox.identify_guard_levels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">guardlev = identify_guard_levels(params[, custom = 0])</code></pre><p>Build a Bool array indicating if a given energy level is a guard level in the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>custom:: Int64</code>: A nonzero value gives a special stirap pulses case</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/plotstatectrl.jl#L269-L278">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.marginalize3-Tuple{objparams,Array{Complex{Float64},3}}" href="#Juqbox.marginalize3-Tuple{objparams,Array{Complex{Float64},3}}"><code>Juqbox.marginalize3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">marg_prob = marginalize3(params, unitaryhist)</code></pre><p>Evaluate marginalized probabilities for the case of 3 subsystems.</p><p><strong>Arguments</strong></p><ul><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>unitaryhist:: Array{Complex{Float64},3})</code>: State vector history for each timestep</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/plotstatectrl.jl#L385-L393">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plot_conv_hist" href="#Juqbox.plot_conv_hist"><code>Juqbox.plot_conv_hist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pconv = plot_conv_hist(params [, convname:: String=&quot;&quot;])</code></pre><p>Plot the optimization convergence history, including history of  the different terms in the objective function and the norm of the gradient.</p><p><strong>Arguments</strong></p><ul><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>convname:: String</code>: Name of plot file to be generated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/plotstatectrl.jl#L414-L423">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plot_results-Tuple{objparams,Array{Float64,1}}" href="#Juqbox.plot_results-Tuple{objparams,Array{Float64,1}}"><code>Juqbox.plot_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pl = plot_results(params, pcof; [casename = &quot;test&quot;, savefiles = false, samplerate = 32])</code></pre><p>Create array of plot objects that can be visualized by, e.g., <code>display(pl[1])</code>.</p><p><strong>Arguments</strong></p><ul><li><code>params::objparams</code>: Object holding problem definition</li><li><code>pcof::Array{Float64,1}</code>: Parameter vector</li><li><code>casename::String</code>: Default: <code>&quot;test&quot;</code>. String used in plot titles and in file names</li><li><code>savefiles::Bool</code>: Default: <code>false</code>.Set to <code>true</code> to save plots on files with automatically generated filenames</li><li><code>samplerate:: Int64</code>: Default: <code>32</code> samples per unit time (ns). Sample rate for generating plots.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/plot-results.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plotspecified-Tuple{Any,Any,Array{Bool,1},Array{Bool,1}}" href="#Juqbox.plotspecified-Tuple{Any,Any,Array{Bool,1},Array{Bool,1}}"><code>Juqbox.plotspecified</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plt = plotspecified(us, params, guardlev, specifiedlev)</code></pre><p>Plot the evolution of the state vector for specified levels.</p><p><strong>Arguments</strong></p><ul><li><code>us:: Array{Complex{Float64},3})</code>: State vector history for each timestep</li><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>us:: Array{Bool,1})</code>: Boolean array indicating if a certain level is a guard level</li><li>&#39;specifiedlev:: Array{Bool,1}&#39;: Boolean array indicating which levels to be plotted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/plotstatectrl.jl#L86-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plotunitary-Tuple{Any,Any,Any}" href="#Juqbox.plotunitary-Tuple{Any,Any,Any}"><code>Juqbox.plotunitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">plt = plotunitary(us, params, guardlev)</code></pre><p>Plot the evolution of the state vector.</p><p><strong>Arguments</strong></p><ul><li><code>us:: Array{Complex{Float64},3})</code>: State vector history for each timestep</li><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>guardlev:: Array{Bool,1})</code>: Boolean array indicating if a certain level is a guard level</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/plotstatectrl.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.read_pcof-Tuple{String}" href="#Juqbox.read_pcof-Tuple{String}"><code>Juqbox.read_pcof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">pcof = read_pcof(refFileName)</code></pre><p>Read the parameter vector <code>pcof</code> from a JLD2 formatted file</p><p><strong>Arguments</strong></p><ul><li><code>refFileName</code>: String holding the name of the file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/save_pcof.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.run_optimizer" href="#Juqbox.run_optimizer"><code>Juqbox.run_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pcof = run_optimizer(prob, pcof0 [, baseName:: String=&quot;&quot;])</code></pre><p>Call IPOPT to  optimizize the control functions.</p><p><strong>Arguments</strong></p><ul><li><code>prob:: IpoptProblem</code>: Struct containing Ipopt parameters callback functions</li><li><code>pcof0:: Array{Float64, 1}</code>: Initial guess for the parameter values</li><li><code>baseName:: String</code>: Name of file for saving the optimized parameters; extension &quot;.jld2&quot; is appended</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/ipopt_interface.jl#L146-L155">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.save_pcof-Tuple{String,Array{Float64,1}}" href="#Juqbox.save_pcof-Tuple{String,Array{Float64,1}}"><code>Juqbox.save_pcof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">save_pcof(refFileName, pcof)</code></pre><p>Save the parameter vector <code>pcof</code> on a JLD2 formatted file with handle <code>pcof</code></p><p><strong>Arguments</strong></p><ul><li><code>refFileName</code>: String holding the name of the file.</li><li><code>pcof</code>: Vector of floats holding the parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/save_pcof.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.setup_ipopt_problem" href="#Juqbox.setup_ipopt_problem"><code>Juqbox.setup_ipopt_problem</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">prob = setup_ipopt_problem(params, wa, nCoeff, minCoeff, maxCoeff [, maxIter=50, 
                        lbfgsMax=10, startFromScratch=true, ipTol=1e-5, acceptTol=1e-5, acceptIter=15])</code></pre><p>Setup structure containing callback functions and convergence criteria for  optimization via IPOPT.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>wa::Working_Arrays</code>: Struct containing preallocated working arrays</li><li><code>nCoeff:: Int64</code>: Number of parameters in optimization</li><li><code>minCoeff:: Array{Float64, 1}</code>: Minimum allowable value for each parameter</li><li><code>maxCoeff:: Array{Float64, 1}</code>: Maximum allowable value for each parameter</li><li><code>maxIter:: Int64</code>: Maximum number of iterations to be taken by optimizer</li><li><code>lbfgsMax:: Int64</code>: Maximum number of past iterates for Hessian approximation by L-BFGS</li><li><code>startFromScratch:: Bool</code>: Specify whether the optimization is starting from file or not</li><li><code>ipTol:: Float64</code>: Desired convergence tolerance (relative)</li><li><code>acceptTol:: Float64</code>: Acceptable convergence tolerance (relative)</li><li><code>acceptIter:: Int64</code>: Number of acceptable iterates before triggering termination</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/ipopt_interface.jl#L72-L91">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.setup_rotmatrices-Tuple{Array{Int64,1},Array{Int64,1},Array{Float64,N} where N}" href="#Juqbox.setup_rotmatrices-Tuple{Array{Int64,1},Array{Int64,1},Array{Float64,N} where N}"><code>Juqbox.setup_rotmatrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">omega1[, omega2, omega3] = setup_rotmatrices(Ne, Ng, fund_freq)</code></pre><p>Build diagonal rotation matrices based on the |0⟩to |1⟩ transition frequency in each sub-system.</p><p><strong>Arguments</strong></p><ul><li><code>Ne::Array{Int64,1}</code>: Number of essential energy levels for each subsystem</li><li><code>Ng::Array{Int64,1}</code>: Number of guard energy levels for each subsystem</li><li><code>fund_freq::Array{Float64}</code>: Transitions frequency [GHz] for each subsystem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L885-L895">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.traceobjgrad" href="#Juqbox.traceobjgrad"><code>Juqbox.traceobjgrad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">objf = traceobjgrad(pcof0, params, wa[, verbose = false, evaladjoint = true])</code></pre><p>Perform a forward and/or adjoint Schrödinger solve to evaluate the objective function and/or gradient.</p><p><strong>Arguments</strong></p><ul><li><code>pcof0::Array{Float64,1}</code>: Array of parameter values defining the controls</li><li><code>param::objparams</code>: Struct with problem definition</li><li><code>wa::Working_Arrays</code>: Struct containing preallocated working arrays</li><li><code>verbose::Bool = false</code>: Run simulation with additional terminal output and store state history.</li><li><code>evaladjoint::Bool = true</code>: Solve the adjoint equation and calculate the gradient of the objective function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L293-L305">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.wmatsetup-Tuple{Array{Int64,1},Array{Int64,1}}" href="#Juqbox.wmatsetup-Tuple{Array{Int64,1},Array{Int64,1}}"><code>Juqbox.wmatsetup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">wmat = wmatsetup(Ne, Ng)</code></pre><p>Build the default positive semi-definite weighting matrix W to calculate the  leakage into higher energy forbidden states</p><p><strong>Arguments</strong></p><ul><li><code>Ne::Array{Int64,1}</code>: Number of essential energy levels for each subsystem</li><li><code>Ng::Array{Int64,1}</code>: Number of guard energy levels for each subsystem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L750-L759">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.zero_start_end!-Tuple{objparams,Int64,Array{Float64,1},Array{Float64,1}}" href="#Juqbox.zero_start_end!-Tuple{objparams,Int64,Array{Float64,1},Array{Float64,1}}"><code>Juqbox.zero_start_end!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">zero_start_end!(params, D1, minCoeff, maxCoeff)</code></pre><p>Force the control functions to start and end at zero by setting zero bounds for the first two and last  two parameters in each B-spline segment.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct containing problem definition.</li><li><code>D1:: Int64</code>: Number of basis functions in each segment.</li><li><code>minCoeff:: Vector{Float64}</code>: Lower parameter bounds to be modified</li><li><code>maxCoeff:: Vector{Float64}</code>: Upper parameter bounds to be modified</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/919ee7d4c606891221dc0912d4ba1f628fe1fd31/src/evalobjgrad.jl#L963-L974">source</a></section></article><h2 id="Index"><a class="docs-heading-anchor" href="#Index">Index</a><a id="Index-1"></a><a class="docs-heading-anchor-permalink" href="#Index" title="Permalink"></a></h2><ul><li><a href="index.html#Juqbox.Working_Arrays"><code>Juqbox.Working_Arrays</code></a></li><li><a href="index.html#Juqbox.bcparams"><code>Juqbox.bcparams</code></a></li><li><a href="index.html#Juqbox.objparams"><code>Juqbox.objparams</code></a></li><li><a href="index.html#Juqbox.splineparams"><code>Juqbox.splineparams</code></a></li><li><a href="index.html#Juqbox.assign_thresholds"><code>Juqbox.assign_thresholds</code></a></li><li><a href="index.html#Juqbox.assign_thresholds_ctrl_freq-Tuple{objparams,Int64,Array{Float64,2}}"><code>Juqbox.assign_thresholds_ctrl_freq</code></a></li><li><a href="index.html#Juqbox.assign_thresholds_freq-Tuple{Array{Float64,1},Int64,Int64,Int64}"><code>Juqbox.assign_thresholds_freq</code></a></li><li><a href="index.html#Juqbox.bcarrier2-Tuple{Float64,bcparams,Int64}"><code>Juqbox.bcarrier2</code></a></li><li><a href="index.html#Juqbox.bspline2-Tuple{Float64,splineparams,Int64}"><code>Juqbox.bspline2</code></a></li><li><a href="index.html#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a></li><li><a href="index.html#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a></li><li><a href="index.html#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a></li><li><a href="index.html#Juqbox.estimate_Neumann!"><code>Juqbox.estimate_Neumann!</code></a></li><li><a href="index.html#Juqbox.evalctrl-Tuple{objparams,Array{Float64,1},Array{Float64,1},Int64}"><code>Juqbox.evalctrl</code></a></li><li><a href="index.html#Juqbox.gradbcarrier2!-Tuple{Float64,bcparams,Int64,Array{Float64,1}}"><code>Juqbox.gradbcarrier2!</code></a></li><li><a href="index.html#Juqbox.gradbspline2-Tuple{Float64,splineparams,Int64}"><code>Juqbox.gradbspline2</code></a></li><li><a href="index.html#Juqbox.identify_forbidden_levels"><code>Juqbox.identify_forbidden_levels</code></a></li><li><a href="index.html#Juqbox.identify_guard_levels"><code>Juqbox.identify_guard_levels</code></a></li><li><a href="index.html#Juqbox.marginalize3-Tuple{objparams,Array{Complex{Float64},3}}"><code>Juqbox.marginalize3</code></a></li><li><a href="index.html#Juqbox.plot_conv_hist"><code>Juqbox.plot_conv_hist</code></a></li><li><a href="index.html#Juqbox.plot_results-Tuple{objparams,Array{Float64,1}}"><code>Juqbox.plot_results</code></a></li><li><a href="index.html#Juqbox.plotspecified-Tuple{Any,Any,Array{Bool,1},Array{Bool,1}}"><code>Juqbox.plotspecified</code></a></li><li><a href="index.html#Juqbox.plotunitary-Tuple{Any,Any,Any}"><code>Juqbox.plotunitary</code></a></li><li><a href="index.html#Juqbox.read_pcof-Tuple{String}"><code>Juqbox.read_pcof</code></a></li><li><a href="index.html#Juqbox.run_optimizer"><code>Juqbox.run_optimizer</code></a></li><li><a href="index.html#Juqbox.save_pcof-Tuple{String,Array{Float64,1}}"><code>Juqbox.save_pcof</code></a></li><li><a href="index.html#Juqbox.setup_ipopt_problem"><code>Juqbox.setup_ipopt_problem</code></a></li><li><a href="index.html#Juqbox.setup_rotmatrices-Tuple{Array{Int64,1},Array{Int64,1},Array{Float64,N} where N}"><code>Juqbox.setup_rotmatrices</code></a></li><li><a href="index.html#Juqbox.traceobjgrad"><code>Juqbox.traceobjgrad</code></a></li><li><a href="index.html#Juqbox.wmatsetup-Tuple{Array{Int64,1},Array{Int64,1}}"><code>Juqbox.wmatsetup</code></a></li><li><a href="index.html#Juqbox.zero_start_end!-Tuple{objparams,Int64,Array{Float64,1},Array{Float64,1}}"><code>Juqbox.zero_start_end!</code></a></li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Friday 5 March 2021 15:09">Friday 5 March 2021</span>. Using Julia version 1.5.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
