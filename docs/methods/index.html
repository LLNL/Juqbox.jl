<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Methods · Juqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Juqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../workflow/">Workflow</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><a class="tocitem" href="../types/">Types</a></li><li class="is-active"><a class="tocitem" href>Methods</a></li><li><a class="tocitem" href="../function-index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Methods</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Methods</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LLNL/Juqbox.jl/blob/master/docs/src/methods.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>The following methods (functions) are exported and available by <code>using Juqbox</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Juqbox.assign_thresholds-Tuple{objparams, Int64, Vector{Float64}}" href="#Juqbox.assign_thresholds-Tuple{objparams, Int64, Vector{Float64}}"><code>Juqbox.assign_thresholds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minCoeff, maxCoeff = assign_thresholds(params, D1, maxpar [, maxpar_unc])</code></pre><p>Build vector of frequency independent min/max parameter constraints for each control function. Here, <code>minCoeff = -maxCoeff</code>.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct containing problem definition.</li><li><code>D1:: Int64</code>: Number of basis functions in each segment.</li><li><code>maxpar::Array{Float64,1}</code>: Maximum parameter value for each coupled control.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L1225-L1234">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.assign_thresholds_ctrl_freq-Tuple{objparams, Int64, Matrix{Float64}}" href="#Juqbox.assign_thresholds_ctrl_freq-Tuple{objparams, Int64, Matrix{Float64}}"><code>Juqbox.assign_thresholds_ctrl_freq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minCoeff, maxCoeff = assign_thresholds_ctrl_freq(params, D1, maxamp)</code></pre><p>Build vector of parameter min/max constraints that can depend on the control function and carrier wave frequency,  with <code>minCoeff = -maxCoeff</code>.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct containing problem definition.</li><li><code>D1:: Int64</code>: Number of basis functions in each segment.</li><li><code>maxamp:: Matrix{Float64}</code>: <code>maxamp[c,f]</code> is the maximum parameter value for ctrl <code>c</code> and frequency <code>f</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L1167-L1177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.assign_thresholds_freq-Tuple{Vector{Float64}, Int64, Int64, Int64}" href="#Juqbox.assign_thresholds_freq-Tuple{Vector{Float64}, Int64, Int64, Int64}"><code>Juqbox.assign_thresholds_freq</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">minCoeff, maxCoeff = assign_thresholds_freq(maxamp, Ncoupled, Nfreq, D1)</code></pre><p>Build vector of frequency dependent min/max parameter constraints, with <code>minCoeff = -maxCoeff</code>, when there are no uncoupled control functions.</p><p><strong>Arguments</strong></p><ul><li><code>maxamp::Array{Float64,1}</code>: Maximum parameter value for each frequency</li><li><code>Ncoupled::Int64</code>: Number of coupled controls in the simulation</li><li><code>Nfreq::Int64</code>: Number of carrier wave frequencies used in the controls</li><li><code>D1:: Int64</code>: Number of basis functions in each control function</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L1197-L1208">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.bcarrier2-Tuple{Float64, bcparams, Int64}" href="#Juqbox.bcarrier2-Tuple{Float64, bcparams, Int64}"><code>Juqbox.bcarrier2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f = bcarrier2(t, params, func)</code></pre><p>Evaluate a B-spline function with carrier waves. See also the <code>bcparams</code> constructor.</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Evaluate spline at parameter t ∈ [0, param.T]</li><li><code>param::params</code>: Parameters for the spline</li><li><code>func::Int64</code>: Spline function index ∈ [0, param.Nseg-1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/bsplines.jl#L201-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.bspline2-Tuple{Float64, splineparams, Int64}" href="#Juqbox.bspline2-Tuple{Float64, splineparams, Int64}"><code>Juqbox.bspline2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">f = bspline2(t, splineparam, splinefunc)</code></pre><p>Evaluate a B-spline function. See also the <code>splineparams</code> constructor.</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Evaluate spline at parameter t ∈ [0, param.T]</li><li><code>param::splineparams</code>: Parameters for the spline</li><li><code>splinefunc::Int64</code>: Spline function index ∈ [0, param.Nseg-1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/bsplines.jl#L35-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.calculate_timestep" href="#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nsteps = calculate_timestep(T, H0, Hunc_ops, maxpar [, Pmin = 40])</code></pre><p>Estimate the number of time steps needed for an accurate simulation, when there are no coupled controls</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Final simulation</li><li><code>H0::Array{Float64,2}</code>: Time-independent part of the Hamiltonian matrix</li><li><code>Hunc_ops:: Array{Float64,2}</code>: Array of uncoupled control Hamiltonians</li><li><code>max_unc:: Array{Float64,1}</code>: Maximum parameter value for each subsystem (uncoupled)</li><li><code>Pmin:: Int64</code>: Sample rate for accuracy (assuming a slowly varying Hamiltonian)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L2170-L2181">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.calculate_timestep" href="#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nsteps = calculate_timestep(T, H0, Hsym_ops, Hanti_ops, maxpar [, Pmin = 40])</code></pre><p>Estimate the number of time steps needed for the simulation, for the case without uncoupled controls.</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Final simulation</li><li><code>H0::Array{Float64,2}</code>: Time-independent part of the Hamiltonian matrix</li><li><code>Hsym_ops:: Array{Float64,2}</code>: Array of symmetric control Hamiltonians</li><li><code>Hanti_ops:: Array{Float64,2}</code>: Array of symmetric control Hamiltonians</li><li><code>maxpar:: Array{Float64,1}</code>: Maximum parameter value for each subsystem</li><li><code>Pmin:: Int64</code>: Number of time steps per shortest period (assuming a slowly varying Hamiltonian).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L2076-L2088">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.calculate_timestep" href="#Juqbox.calculate_timestep"><code>Juqbox.calculate_timestep</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">nsteps = calculate_timestep(T, H0, Hsym_ops, Hanti_ops, Hunc_ops, 
                                          maxpar, max_flux[, Pmin = 40])</code></pre><p>Estimate the number of time steps needed for the simulation, when there are uncoupled controls.</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Final simulation</li><li><code>H0::Array{Float64,2}</code>: Time-independent part of the Hamiltonian matrix</li><li><code>Hsym_ops:: Array{Float64,2}</code>: Array of symmetric control Hamiltonians</li><li><code>Hanti_ops:: Array{Float64,2}</code>: Array of symmetric control Hamiltonians</li><li><code>Hunc_ops:: Array{Float64,2}</code>: Array of uncoupled control Hamiltonians</li><li><code>maxpar:: Array{Float64,1}</code>: Maximum parameter value for each coupled control</li><li><code>max_flux:: Array{Float64,1}</code>: Maximum parameter value for each uncoupled control</li><li><code>Pmin:: Int64</code>: Number of time steps per shortest period (assuming a slowly varying Hamiltonian).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L2112-L2127">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.estimate_Neumann!" href="#Juqbox.estimate_Neumann!"><code>Juqbox.estimate_Neumann!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">estimate_Neumann!(tol, params, maxpar[, maxunc])</code></pre><p>Estimate the number of terms needed by the Neumann series approach for solving the linear system during the implicit steps of the Störmer-Verlet scheme. See also neumann!</p><p><strong>Arguments</strong></p><ul><li><code>tol:: Float64</code>: Error tolerance in inverting implicit SV term</li><li><code>params:: objparams</code>: Struct containing problem definition</li><li><code>maxpar:: Array{Float64,1}</code>: Maximum parameter value for each coupled control</li><li><code>maxunc:: Array{Float64,1}</code>: (optional) Maximum parameter value for each uncoupled controls</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L2024-L2035">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.evalctrl-Tuple{objparams, Vector{Float64}, Vector{Float64}, Int64}" href="#Juqbox.evalctrl-Tuple{objparams, Vector{Float64}, Vector{Float64}, Int64}"><code>Juqbox.evalctrl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pj [, qj] = evalctrl(params, pcof0, td, func)</code></pre><p>Evaluate the control function with index <code>func</code> at an array of time levels <code>td</code>.  </p><p>NOTE: the control function index <code>func</code> is 1-based. </p><p>NOTE: The return value(s) depend on <code>func</code>. For <code>func∈[1,Ncoupled]</code>, <code>pj, qj</code> are returned. Otherwise,  only <code>pj</code> is returned, corresponding to control number <code>func</code>.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>pcof0:: Array{Float64,1})</code>: Vector of parameter values</li><li><code>td:: Array{Float64,1})</code>: Time values control is to be evaluated</li><li><code>jFunc:: Int64</code>: Index of the control signal desired</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L230-L245">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.gradbcarrier2!-Tuple{Float64, bcparams, Int64, Vector{Float64}}" href="#Juqbox.gradbcarrier2!-Tuple{Float64, bcparams, Int64, Vector{Float64}}"><code>Juqbox.gradbcarrier2!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gradbcarrier2!(t, params, func, g) -&gt; g</code></pre><p>Evaluate the gradient of a control function with respect to all coefficient.</p><p>NOTE: the index of the control functions is 0-based. For a set of  coupled controls, mod(<code>func</code>,2)=0 corresponds to ∇ p<em>j(t) and mod(<code>func</code>,2) = 1  corresponds to ∇ q</em>j(t), where j = div(func,2).</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Evaluate spline at parameter t ∈ [0, param.T]</li><li><code>params::bcparams</code>: Parameters for the spline</li><li><code>func::Int64</code>: Control function index ∈ [0, param.Nseg-1]</li><li><code>g::Array{Float64,1}</code>: Preallocated array to store calculated gradient</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/bsplines.jl#L307-L320">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.gradbspline2-Tuple{Float64, splineparams, Int64}" href="#Juqbox.gradbspline2-Tuple{Float64, splineparams, Int64}"><code>Juqbox.gradbspline2</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g = gradbspline2(t, param, splinefunc)</code></pre><p>Evaluate the gradient of a spline function with respect to all coefficient. NOTE: the index of the spline functions are 0-based. For a set of  coupled controls, mod(<code>splinefunc</code>,2)=0 corresponds to ∇ p<em>j(t) and mod(<code>splinefunc</code>,2) = 1  corresponds to ∇ q</em>j(t), where j = div(splinefunc,2).</p><p><strong>Arguments</strong></p><ul><li><code>t::Float64</code>: Evaluate spline at parameter t ∈ [0, param.T]</li><li><code>param::splineparams</code>: Spline parameter object</li><li><code>splinefunc::Int64</code>: Spline function index ∈ [0, param.Nseg-1]</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/bsplines.jl#L73-L85">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.identify_forbidden_levels" href="#Juqbox.identify_forbidden_levels"><code>Juqbox.identify_forbidden_levels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">forbiddenlev = identify_forbidden_levels(params[, custom = 0])</code></pre><p>Build a Bool array indicating which energy levels are forbidden levels in the state vector. The forbidden levels in a state vector are defined as thos corresponding to the highest energy level in at least one of its subsystems.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>custom:: Int64</code>: For nonzero value special stirap pulses case</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L323-L333">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.identify_guard_levels" href="#Juqbox.identify_guard_levels"><code>Juqbox.identify_guard_levels</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">guardlev = identify_guard_levels(params[, custom = 0])</code></pre><p>Build a Bool array indicating if a given energy level is a guard level in the simulation.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>custom:: Int64</code>: A nonzero value gives a special stirap pulses case</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L279-L288">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.initial_cond-Tuple{Any, Any}" href="#Juqbox.initial_cond-Tuple{Any, Any}"><code>Juqbox.initial_cond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">u_init = initial_cond(Ne, Ng)</code></pre><p>Setup a basis of canonical unit vectors that span the essential Hilbert space, setting all guard levels to zero</p><p><strong>Arguments</strong></p><ul><li><code>Ne:: Array{Int64}</code>: Array holding the number of essential levels in each system</li><li><code>Ng:: Array{Int64}</code>: Array holding the number of guard levels in each system</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L2290-L2298">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.juq2qis" href="#Juqbox.juq2qis"><code>Juqbox.juq2qis</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">juq2qis(params, pcof, samplerate, q_ind, fileName=&quot;ctrl.dat&quot;, node_loc=&quot;c&quot;)</code></pre><p>Evaluate control functions and export them into a format that is readable by Qiskit.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>pcof:: Array{Float64,1})</code>: Vector of parameter values</li><li><code>samplerate:: Float64</code>: Samplerate for quantum device (number of samples per ns for the IQ mixer)</li><li><code>q_ind:: Int64</code>: Index of the control function to output (<code>1 &lt;= q_ind &lt;= Nctrl*Nfreq</code>)</li><li><code>fileName:: String</code>: Name of output file containing controls to be handled by Qiskit</li><li><code>node_loc:: String</code>: Node location, &quot;c&quot; for cell centered, &quot;n&quot; for node-centered, default is cell-centered</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/save_pcof.jl#L30-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.marginalize3-Tuple{objparams, Array{ComplexF64, 3}}" href="#Juqbox.marginalize3-Tuple{objparams, Array{ComplexF64, 3}}"><code>Juqbox.marginalize3</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">marg_prob = marginalize3(params, unitaryhist)</code></pre><p>Evaluate marginalized probabilities for the case of 3 subsystems.</p><p><strong>Arguments</strong></p><ul><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>unitaryhist:: Array{Complex{Float64},3})</code>: State vector history for each timestep</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L396-L404">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plot_conv_hist" href="#Juqbox.plot_conv_hist"><code>Juqbox.plot_conv_hist</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pconv = plot_conv_hist(params [, convname:: String=&quot;&quot;])</code></pre><p>Plot the optimization convergence history, including history of  the different terms in the objective function and the norm of the gradient.</p><p><strong>Arguments</strong></p><ul><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>convname:: String</code>: Name of plot file to be generated</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L425-L434">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plot_energy-Tuple{Array{ComplexF64, 3}, objparams}" href="#Juqbox.plot_energy-Tuple{Array{ComplexF64, 3}, objparams}"><code>Juqbox.plot_energy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plt =  plot_energy(unitaryhistory, params)</code></pre><p>Plot the evolution of the expected energy for each initial condition.</p><p><strong>Arguments</strong></p><ul><li><code>unitaryhistory:: Array{ComplexF64,3}</code>: Array holding the time evolution of the state for each initial condition</li><li><code>params:: objparams</code>: Struct with problem definition</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L501-L509">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plot_final_unitary-Tuple{Matrix{ComplexF64}, objparams, Float64}" href="#Juqbox.plot_final_unitary-Tuple{Matrix{ComplexF64}, objparams, Float64}"><code>Juqbox.plot_final_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plt =  plot_final_unitary(final_unitary, params)</code></pre><p>Plot the essential levels of the solution operator at a fixed time and return a plot handle</p><p><strong>Arguments</strong></p><ul><li><code>final_unitary:: Array{ComplexF64,2}</code>: Ntot by Ness array holding the final state for each initial condition</li><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>fid:: Float64</code>: Gate fidelity (for plot title)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L463-L472">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plot_results-Tuple{objparams, Vector{Float64}}" href="#Juqbox.plot_results-Tuple{objparams, Vector{Float64}}"><code>Juqbox.plot_results</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pl = plot_results(params, pcof; [casename = &quot;test&quot;, savefiles = false, samplerate = 32])</code></pre><p>Create array of plot objects that can be visualized by, e.g., <code>display(pl[1])</code>.</p><p><strong>Arguments</strong></p><ul><li><code>params::objparams</code>: Object holding problem definition</li><li><code>pcof::Array{Float64,1}</code>: Parameter vector</li><li><code>casename::String</code>: Default: <code>&quot;test&quot;</code>. String used in plot titles and in file names</li><li><code>savefiles::Bool</code>: Default: <code>false</code>.Set to <code>true</code> to save plots on files with automatically generated filenames</li><li><code>samplerate:: Int64</code>: Default: <code>32</code> samples per unit time (ns). Sample rate for generating plots.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plot-results.jl#L1-L12">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plotspecified-Tuple{Any, Any, Vector{Bool}, Vector{Bool}}" href="#Juqbox.plotspecified-Tuple{Any, Any, Vector{Bool}, Vector{Bool}}"><code>Juqbox.plotspecified</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plt = plotspecified(us, params, guardlev, specifiedlev)</code></pre><p>Plot the evolution of the state vector for specified levels.</p><p><strong>Arguments</strong></p><ul><li><code>us:: Array{Complex{Float64},3})</code>: State vector history for each timestep</li><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>guardlev:: Array{Bool,1})</code>: Boolean array indicating if a certain level is a guard level</li><li><code>specifiedlev:: Array{Bool,1}</code>: Boolean array indicating which levels to be plotted</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L99-L109">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.plotunitary-Tuple{Any, Any, Any}" href="#Juqbox.plotunitary-Tuple{Any, Any, Any}"><code>Juqbox.plotunitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">plt = plotunitary(us, params, guardlev)</code></pre><p>Plot the evolution of the state vector.</p><p><strong>Arguments</strong></p><ul><li><code>us:: Array{Complex{Float64},3})</code>: State vector history for each timestep</li><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>guardlev:: Array{Bool,1})</code>: Boolean array indicating if a certain level is a guard level</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/plotstatectrl.jl#L2-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.read_pcof-Tuple{String}" href="#Juqbox.read_pcof-Tuple{String}"><code>Juqbox.read_pcof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pcof = read_pcof(refFileName)</code></pre><p>Read the parameter vector <code>pcof</code> from a JLD2 formatted file</p><p><strong>Arguments</strong></p><ul><li><code>refFileName</code>: String holding the name of the file.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/save_pcof.jl#L16-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.run_optimizer" href="#Juqbox.run_optimizer"><code>Juqbox.run_optimizer</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">pcof = run_optimizer(prob, pcof0 [, baseName:: String=&quot;&quot;])</code></pre><p>Call IPOPT to  optimizize the control functions.</p><p><strong>Arguments</strong></p><ul><li><code>prob:: IpoptProblem</code>: Struct containing Ipopt parameters callback functions</li><li><code>pcof0:: Array{Float64, 1}</code>: Initial guess for the parameter values</li><li><code>baseName:: String</code>: Name of file for saving the optimized parameters; extension &quot;.jld2&quot; is appended</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/ipopt_interface.jl#L394-L403">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.save_pcof-Tuple{String, Vector{Float64}}" href="#Juqbox.save_pcof-Tuple{String, Vector{Float64}}"><code>Juqbox.save_pcof</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">save_pcof(refFileName, pcof)</code></pre><p>Save the parameter vector <code>pcof</code> on a JLD2 formatted file with handle <code>pcof</code></p><p><strong>Arguments</strong></p><ul><li><code>refFileName</code>: String holding the name of the file.</li><li><code>pcof</code>: Vector of floats holding the parameters.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/save_pcof.jl#L3-L11">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.setup_ipopt_problem-Tuple{objparams, Working_Arrays, Int64, Vector{Float64}, Vector{Float64}}" href="#Juqbox.setup_ipopt_problem-Tuple{objparams, Working_Arrays, Int64, Vector{Float64}, Vector{Float64}}"><code>Juqbox.setup_ipopt_problem</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prob = setup_ipopt_problem(params, wa, nCoeff, minCoeff, maxCoeff; maxIter=50, 
                        lbfgsMax=10, startFromScratch=true, ipTol=1e-5, acceptTol=1e-5, acceptIter=15,
                        nodes=[0.0], weights=[1.0])</code></pre><p>Setup structure containing callback functions and convergence criteria for  optimization via IPOPT. Note the last two inputs, <code>nodes&#39;, and</code>weights&#39;, are to be used when performing a simple risk-neutral optimization where the fundamental frequency is random.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct with problem definition</li><li><code>wa::Working_Arrays</code>: Struct containing preallocated working arrays</li><li><code>nCoeff:: Int64</code>: Number of parameters in optimization</li><li><code>minCoeff:: Array{Float64, 1}</code>: Minimum allowable value for each parameter</li><li><code>maxCoeff:: Array{Float64, 1}</code>: Maximum allowable value for each parameter</li><li><code>maxIter:: Int64</code>: Maximum number of iterations to be taken by optimizer (keyword arg)</li><li><code>lbfgsMax:: Int64</code>: Maximum number of past iterates for Hessian approximation by L-BFGS (keyword arg)</li><li><code>startFromScratch:: Bool</code>: Specify whether the optimization is starting from file or not (keyword arg)</li><li><code>ipTol:: Float64</code>: Desired convergence tolerance (relative) (keyword arg)</li><li><code>acceptTol:: Float64</code>: Acceptable convergence tolerance (relative) (keyword arg)</li><li><code>acceptIter:: Int64</code>: Number of acceptable iterates before triggering termination (keyword arg)</li><li><code>nodes:: Array{Float64, 1}</code>: Risk-neutral opt: User specified quadrature nodes on the interval [-ϵ,ϵ] for some ϵ (keyword arg)</li><li><code>weights:: Array{Float64, 1}</code>: Risk-neutral opt: User specified quadrature weights on the interval [-ϵ,ϵ] for some ϵ (keyword arg)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/ipopt_interface.jl#L242-L266">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.setup_rotmatrices-Tuple{Vector{Int64}, Vector{Int64}, Array{Float64}}" href="#Juqbox.setup_rotmatrices-Tuple{Vector{Int64}, Vector{Int64}, Array{Float64}}"><code>Juqbox.setup_rotmatrices</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">omega1[, omega2, omega3] = setup_rotmatrices(Ne, Ng, fund_freq)</code></pre><p>Build diagonal rotation matrices based on the |0⟩to |1⟩ transition frequency in each sub-system.</p><p><strong>Arguments</strong></p><ul><li><code>Ne::Array{Int64,1}</code>: Number of essential energy levels for each subsystem</li><li><code>Ng::Array{Int64,1}</code>: Number of guard energy levels for each subsystem</li><li><code>fund_freq::Array{Float64}</code>: Transitions frequency [GHz] for each subsystem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L1047-L1057">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.traceobjgrad" href="#Juqbox.traceobjgrad"><code>Juqbox.traceobjgrad</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">objf = traceobjgrad(pcof0, params, wa[, verbose = false, evaladjoint = true])</code></pre><p>Perform a forward and/or adjoint Schrödinger solve to evaluate the objective function and/or gradient.</p><p><strong>Arguments</strong></p><ul><li><code>pcof0::Array{Float64,1}</code>: Array of parameter values defining the controls</li><li><code>param::objparams</code>: Struct with problem definition</li><li><code>wa::Working_Arrays</code>: Struct containing preallocated working arrays</li><li><code>verbose::Bool = false</code>: Run simulation with additional terminal output and store state history.</li><li><code>evaladjoint::Bool = true</code>: Solve the adjoint equation and calculate the gradient of the objective function.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L393-L405">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.wmatsetup-Tuple{Vector{Int64}, Vector{Int64}}" href="#Juqbox.wmatsetup-Tuple{Vector{Int64}, Vector{Int64}}"><code>Juqbox.wmatsetup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">wmat = wmatsetup(Ne, Ng)</code></pre><p>Build the default positive semi-definite weighting matrix W to calculate the  leakage into higher energy forbidden states</p><p><strong>Arguments</strong></p><ul><li><code>Ne::Array{Int64,1}</code>: Number of essential energy levels for each subsystem</li><li><code>Ng::Array{Int64,1}</code>: Number of guard energy levels for each subsystem</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L909-L918">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.zero_start_end!-Tuple{objparams, Int64, Vector{Float64}, Vector{Float64}}" href="#Juqbox.zero_start_end!-Tuple{objparams, Int64, Vector{Float64}, Vector{Float64}}"><code>Juqbox.zero_start_end!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">zero_start_end!(params, D1, minCoeff, maxCoeff)</code></pre><p>Force the control functions to start and end at zero by setting zero bounds for the first two and last  two parameters in each B-spline segment.</p><p><strong>Arguments</strong></p><ul><li><code>params:: objparams</code>: Struct containing problem definition.</li><li><code>D1:: Int64</code>: Number of basis functions in each segment.</li><li><code>minCoeff:: Vector{Float64}</code>: Lower parameter bounds to be modified</li><li><code>maxCoeff:: Vector{Float64}</code>: Upper parameter bounds to be modified</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/aafe040a96d9f5ca99521404681f466681099c92/src/evalobjgrad.jl#L1125-L1136">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../types/">« Types</a><a class="docs-footer-nextpage" href="../function-index/">Index »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.22 on <span class="colophon-date" title="Friday 19 August 2022 23:33">Friday 19 August 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
