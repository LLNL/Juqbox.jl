<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Types · Juqbox.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">Juqbox.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../workflow/">Workflow</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>Types</a></li><li><a class="tocitem" href="../methods/">Methods</a></li><li><a class="tocitem" href="../function-index/">Index</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Types</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Types</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/LLNL/Juqbox.jl/blob/master/docs/src/types.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><p>The following types are exported and available by <code>using Juqbox</code>.</p><article class="docstring"><header><a class="docstring-binding" id="Juqbox.Working_Arrays" href="#Juqbox.Working_Arrays"><code>Juqbox.Working_Arrays</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">wa = Working_Arrays(params::objparams, nCoeff::Int64)</code></pre><p>Constructor for the mutable struct Working_Arrays containing preallocated working arrays.</p><p><strong>Arguments</strong></p><ul><li><code>param:: objparams</code>: Struct with problem definition</li><li><code>nCoeff:: Int64</code>: Number of parameters in optimization</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/a4e1564790e82b0524f4371ea1f5e5990e5d48a6/src/evalobjgrad.jl#L331-L340">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.bcparams" href="#Juqbox.bcparams"><code>Juqbox.bcparams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">bcpar = bcparams(T, D1, Ncoupled, Nunc, omega, pcof)</code></pre><p>General constructor of <code>struct bcparams</code> for setting up B-splines with carrier waves.</p><pre><code class="nohighlight hljs">bcpar = bcparams(T, D1, omega, pcof)</code></pre><p>Simplified constructor for the case when there are no uncoupled controls and <code>Ncoupled = size(omega,1)</code>.</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Duration of spline function</li><li><code>D1:: Int64</code>: Number of basis functions in each segment</li><li><code>Ncoupled::Int64</code>: Number of coupled controls in the simulation</li><li><code>Nunc::Int64</code>: Number of uncoupled controls in the simulation</li><li><code>omega::Array{Float64,2}</code>: Carrier wave frequencies</li><li><code>pcof:: Array{Float64, 1}</code>: Coefficient vector. Must have D1*Nseg elements</li></ul><p><strong>First dimensions of the <code>omega</code> array:</strong></p><ul><li>Without uncoupled controls, <code>Nunc=0</code> and <code>size(omega,1) = Ncoupled</code>.</li><li>With uncoupled controls, <code>Nunc &gt; 0</code> and <code>size(omega,1) = Ncoupled + Nunc</code>.</li></ul><p><strong>Second dimension of the <code>omega</code> array:</strong></p><ul><li><code>size(omega, 2) = Nfreq</code></li></ul><p><strong>Ordering of the <code>pcof</code> array:</strong></p><p>First consider the case without uncoupled control functions, <code>Nunc = 0</code>:  Then the <code>pcof</code> array then has <code>2*Ncoupled*Nfreq*D1</code> elements.  Each <code>ctrl ∈ [1,Ncoupled]</code> and <code>freq ∈ [1,Nfreq]</code> corresponds to <code>D1</code> elements in  the <code>pcof</code> vector. For the case <code>Ncoupled = 2</code> and <code>Nfreq = 2</code>, the elements are ordered according to</p><table><tr><th style="text-align: right">ctrl</th><th style="text-align: right">freq</th><th style="text-align: right">α_1</th><th style="text-align: right">α_2</th></tr><tr><td style="text-align: right">1</td><td style="text-align: right">1</td><td style="text-align: right">1:D1</td><td style="text-align: right">D1+1:2 D1</td></tr><tr><td style="text-align: right">1</td><td style="text-align: right">2</td><td style="text-align: right">2 D1+1: 3 D1</td><td style="text-align: right">3 D1+1:4 D1</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">1</td><td style="text-align: right">4 D1+1: 5 D1</td><td style="text-align: right">5 D1+1:6 D1</td></tr><tr><td style="text-align: right">2</td><td style="text-align: right">2</td><td style="text-align: right">6 D1+1: 7 D1</td><td style="text-align: right">7 D1+1: 8D1</td></tr></table><p>If there are uncoupled controls, <code>Nunc &gt; 0</code>, the <code>pcof</code> array should have <code>(2*Ncoupled + Nunc)*Nfreq*D1</code> elements.  The last <code>Nunc*Nfreq*D1</code> elements correspond to the uncoupled control functions and are ordered in a corresponding way.</p><p><strong>External links</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Spline_wavelet#Quadratic_B-spline">Spline Wavelet</a> on Wikipedia.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/a4e1564790e82b0524f4371ea1f5e5990e5d48a6/src/bsplines.jl#L117-L159">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.lsolver_object" href="#Juqbox.lsolver_object"><code>Juqbox.lsolver_object</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">linear_solver = lsolver_object(; tol  = tol,
                                 iter = iter,
                                 nrhs = nrhs,
                                 solver = NEUMANN_SOLVER)</code></pre><p>Constructor for the mutable struct lsolver_object. That allcoates arrays and sets up the function pointers 	for the different linear solvers supported.</p><p><strong>Arguments</strong></p><ul><li><code>tol::Float64  = 1e-10</code> : Convergence tolerance of the iterative solver (only needed for Jacobi)</li><li><code>iter::Int64   = 3</code> : Number of iterations for the linear solver</li><li><code>nrhs::Int64   = 1</code> : Number of right-hand sides (used for tolerance scaling)</li><li><code>solver::Int64 = NEUMANN_SOLVER</code> : (keyword) ID of the iterative solver.                                    Can take the value of NEUMANN<em>SOLVER (i.e. 1) or JACOBI</em>SOLVER (i.e. 2)                                    See examples/cnot2-jacobi-setup.jl</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/a4e1564790e82b0524f4371ea1f5e5990e5d48a6/src/linear_solvers.jl#L10-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.objparams" href="#Juqbox.objparams"><code>Juqbox.objparams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">params = objparams(Ne, Ng, T, Nsteps;
                    Uinit=Uinit, 
                    Utarget=Utarget,
                    Cfreq=Cfreq, 
                    Rfreq=Rfreq, 
                    Hconst=Hconst [, 
                    Hsym_ops=Hsym_ops,
                    Hanti_ops=Hanti_ops, 
                    Hunc_ops=Hunc_ops,
                    wmatScale=wmatScale,
                    objFuncType=objFuncType,
                    leak_lbound=leak_lbound,
                    leak_ubound=leak_ubound,
                    linear_solver = lsolver_object(),
                    use_sparse = use_sparse],
                    dVds = dVds)</code></pre><p>Constructor for the mutable struct objparams. The sizes of the arrays in the argument list are based on <code>Ntot = prod(Ne + Ng)</code>, <code>Ness = prod(Ne)</code>, <code>Nosc = length(Ne) = length(Ng)</code>.</p><p>Notes: It is assumed that <code>length(Hsym_ops) = length(Hanti_ops) =: Ncoupled</code>. The matrices <code>Hconst</code>, <code>Hsym_ops[j]</code>and <code>Hanti_ops[j]</code>, for j∈[1,Ncoupled], must all be of size <code>Ntot × Ntot</code>. The matrices <code>Hsym_ops[j]</code> must be symmetric and <code>Hanti_ops[j]</code> must be skew-symmetric. The matrices <code>Hunc_ops[j]</code>, for j∈[1,Nunc], where <code>Nunc = length(Hunc_ops)</code>, must also be of size <code>Ntot × Ntot</code> and either be symmetric or skew-symmetric.</p><p><strong>Arguments</strong></p><ul><li><code>Ne::Array{Int64,1}</code>: Number of essential energy levels for each subsystem</li><li><code>Ng::Array{Int64,1}</code>: Number of guard energy levels for each subsystem</li><li><code>T::Float64</code>: Duration of gate</li><li><code>Nsteps::Int64</code>: Number of timesteps for integrating Schroedinger&#39;s equation</li><li><code>Uinit::Array{Float64,2}</code>: (keyword) Matrix holding the initial conditions for the solution matrix of size Uinit[Ntot, Ness]</li><li><code>Utarget::Array{Complex{Float64},2}</code>: (keyword) Matrix holding the target gate matrix of size Uinit[Ntot, Ness]</li><li><code>Cfreq::Array{Float64,2}</code>: (keyword) Carrier wave (angular) frequencies of size Cfreq[Nctrl, Nfreq]</li><li><code>Rfreq::Array{Float64,1}</code>: (keyword) Rotational (regular) frequencies for each control Hamiltonian; size Rfreq[Nctrl]</li><li><code>Hconst::Array{Float64,2}</code>: (keyword) Time-independent part of the Hamiltonian matrix of size Ntot × Ntot</li><li><code>Hsym_ops:: Array{Array{Float64,2},1}</code>: (keyword) Array of symmetric control Hamiltonians, each of size Ntot × Ntot</li><li><code>Hanti_ops:: Array{Array{Float64,2},1}</code>: (keyword) Array of anti-symmetric control Hamiltonians, each of size Ntot × Ntot</li><li><code>Hunc_ops:: Array{Array{Float64,2},1}</code>: (keyword) Array of uncoupled control Hamiltonians, each of size Ntot × Ntot</li><li><code>wmatScale::Float64 = 1.0</code>: (keyword) Scaling factor for suppressing guarded energy levels</li><li><code>objFuncType::Int64 = 1</code>  # 1 = objective function include infidelity and leakage                           # 2 = objective function only includes infidelity... no leakage in obj function or constraint                           # 3 = objective function only includes infidelity; leakage treated as inequality constraint</li><li><code>leak_lbound::Float64 = -1.0e19</code> : The lower bound on the leakage inequality constraint (typically -1e19)</li><li><code>leak_ubound::Float64 = 1.0e-3</code>  : The upper bound on the leakage inequality constraint (See examples/cnot2-leakieq-setup.jl )</li><li><code>linear_solver::lsolver_object = lsolver_object()</code> : The linear solver object used to solve the implicit &amp; adjoint system</li><li><code>use_sparse::Bool = false</code>: (keyword) Set to true to sparsify all Hamiltonian matrices</li><li><code>dVds::Array{Complex{Float64},2}</code>: (keyword) Matrix holding the complex-valued matrix dV/ds of size Ntot x Ne (for continuation)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/a4e1564790e82b0524f4371ea1f5e5990e5d48a6/src/evalobjgrad.jl#L1-L50">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Juqbox.splineparams" href="#Juqbox.splineparams"><code>Juqbox.splineparams</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">spar = splineparams(T, D1, Nseg, pcof)</code></pre><p>Constructor for struct splineparams, which sets up the parameters for a regular B-spline function (without carrier waves).</p><p><strong>Arguments</strong></p><ul><li><code>T:: Float64</code>: Duration of spline function</li><li><code>D1:: Int64</code>: Number of basis functions in each spline</li><li><code>Nseg:: Int64</code>:  Number of splines (real, imaginary, different ctrl func)</li><li><code>pcof:: Array{Float64, 1}</code>: Coefficient vector. Must have D1*Nseg elements</li></ul><p><strong>External links</strong></p><ul><li><a href="https://en.wikipedia.org/wiki/Spline_wavelet#Quadratic_B-spline">Spline Wavelet</a> on Wikipedia.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/LLNL/Juqbox.jl/blob/a4e1564790e82b0524f4371ea1f5e5990e5d48a6/src/bsplines.jl#L1-L15">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><a class="docs-footer-nextpage" href="../methods/">Methods »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.23 on <span class="colophon-date" title="Friday 23 September 2022 20:29">Friday 23 September 2022</span>. Using Julia version 1.6.7.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
